// Copyright 2020 Portieris Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vulnerability

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"sync"
	"time"

	ibmcloud "github.com/IBM/go-sdk-core/v4/core"
	"github.com/IBM/portieris/helpers/credential"
	"github.com/IBM/portieris/helpers/image"
	"github.com/golang/glog"
)

const maxRetries = 3

var sleepTime = time.Second

// IBMVAScanner is a client wrapper for interacting with Vulnerability Advisor for IBM Cloud Container Registry API
type IBMVAScanner struct {
	credentials          credential.Credentials
	client               HTTPClient
	Timeout              int64
	AccountHeader        string
	authenticatorFactory authenticatorFactory
}

// HTTPClient makes testing IBMVAScanner simpler
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

var (
	// ErrorUnauthorised is a typed error for unauthorised requests
	ErrorUnauthorised = errors.New("unauthorised")
)

// NewIBMVulnerabilityAdvisorScanner returns a new client for IBM's Vulnerability Advisor
func NewIBMVulnerabilityAdvisorScanner(credentials credential.Credentials, account string) *IBMVAScanner {
	return &IBMVAScanner{
		credentials:   credentials,
		AccountHeader: account,
		client: &http.Client{
			Timeout: time.Second * time.Duration(10),
		},
		authenticatorFactory: authenticatorFactory{},
	}
}

// IBMVASummary represents the summary datatype returned by the VA API
type IBMVASummary struct {
	Status                        string `json:"status" description:"Overall vulnerability assessment status from: OK, WARN, BLOCK, UNSUPPORTED, INCOMPLETE, UNSCANNED"`
	ScanTime                      int64  `json:"scan_time" description:"The scan time of the report as a UNIX timestamp"`
	IssueCount                    int    `json:"issue_count" description:"The number of issues found"`
	ExemptIssueCount              int    `json:"exempt_issue_count" description:"The number of exempt issues found"`
	VulnerabilityCount            int    `json:"vulnerability_count" description:"The number of vulnerability issues found"`
	ExemptVulnerabilityCount      int    `json:"exempt_vulnerability_count" description:"The number of exempt vulnerability issues found"`
	ConfigurationIssueCount       int    `json:"configuration_issue_count" description:"The number of configuration issues found"`
	ExemptConfigurationIssueCount int    `json:"exempt_configuration_issue_count" description:"The number of exempt configuration issues found"`
}

// CanImageDeployBasedOnVulnerabilities is an implementation of the Scanner interface for IBM VA
func (c *IBMVAScanner) CanImageDeployBasedOnVulnerabilities(image image.Reference) (scan ScanResponse, err error) {
	if !image.HasIBMRepo() {
		return scan, fmt.Errorf("Cannot use IBM Vulnerability Advisor with image %q", image.String())
	}
	var summary IBMVASummary
	summary, err = c.getImageStatus(image)
	if err == nil {
		switch summary.Status {
		// WARN is returned when exemptions cover all of the vulnerabilities in the image
		case "OK", "WARN", "UNSUPPORTED":
			glog.Infof("Image %s CAN DEPLOY with IBM VA status %q", image.String(), summary.Status)
			scan.CanDeploy = true
		default:
			reason := fmt.Sprintf("Image %s CANNOT DEPLOY with IBM VA status %q", image.String(), summary.Status)
			glog.Info(reason)
			scan.DenyReason = reason
		}
	} else {
		reason := fmt.Sprintf("Image %s CANNOT DEPLOY due to IBM VA error: %q", image.String(), err)
		glog.Info(reason)
		scan.DenyReason = reason
	}
	return
}

// internal call to VA - API docs: https://cloud.ibm.com/apidocs/container-registry/va#imagestatusquerypath
// GET /va/api/v3/report/image/status/{name}
func (c *IBMVAScanner) getImageStatus(image image.Reference) (IBMVASummary, error) {
	if len(c.credentials) == 0 {
		return IBMVASummary{}, fmt.Errorf("No credentials on client to call VA with")
	}

	uri := fmt.Sprintf("https://%s/va/api/v3/report/image/status/%s", image.GetHostname(), image.String())

	var summary *IBMVASummary
	for _, cred := range c.credentials {
		sum, err := c.callVA(cred, uri)
		switch {
		case err == nil:
			break
		case errors.Is(err, ErrorUnauthorised):
			continue
		default:
			return IBMVASummary{}, fmt.Errorf("Failed to get IBM vulnerability advisor scan result for %q: %v", image.String(), err)
		}

		if sum != nil {
			summary = sum
			break
		}
	}

	if summary == nil {
		return IBMVASummary{}, fmt.Errorf("Not authorised to get IBM vulnerability scan result for %q: %w", image.String(), ErrorUnauthorised)
	}

	return *summary, nil
}

func (c *IBMVAScanner) callVA(cred credential.Credential, uri string) (*IBMVASummary, error) {
	req, err := c.createRequest(cred, uri)
	if err != nil {
		return nil, err
	}

	if c.AccountHeader != "" {
		req.Header.Add("Account", c.AccountHeader)
	}

	for try := 0; try < maxRetries; try++ {
		// Exponential backoff
		time.Sleep(sleepTime * time.Duration(try))

		var resp *http.Response
		resp, err = c.client.Do(req)
		if err != nil {
			continue
		}

		defer resp.Body.Close()

		switch resp.StatusCode {
		case http.StatusOK:
			break
		case http.StatusUnauthorized, http.StatusForbidden:
			return nil, ErrorUnauthorised
		case http.StatusNotFound:
			return nil, errors.New("Not found")
		case http.StatusBadRequest:
			return nil, errors.New("Bad request")
		case http.StatusBadGateway, http.StatusInternalServerError, http.StatusServiceUnavailable:
			err = errors.New("Internal server error")
			continue
		default:
			err = errors.New("Unhandled response from IBM Vulnerability Advisor")
			continue
		}

		decoder := json.NewDecoder(resp.Body)
		summary := &IBMVASummary{}
		err = decoder.Decode(summary)
		if err != nil {
			return summary, err
		}

		return summary, nil
	}

	return &IBMVASummary{}, err
}

func (c *IBMVAScanner) createRequest(cred credential.Credential, uri string) (*http.Request, error) {
	req, _ := http.NewRequest(http.MethodGet, uri, nil)
	if cred.Username == "iamapikey" {
		glog.Info("Exchanging IAM API key for bearer token")
		authenticator, err := c.getAuthenticator(cred)
		if err == nil {
			authErr := authenticator.Authenticate(req)
			if authErr == nil {
				return req, authErr
			}

			glog.Infof("IAM Authenticate returned error: %q, falling back to username/password", authErr)
		} else {
			glog.Infof("Error getting IAM authenticator: %q, falling back to username/password", err)
		}
	}

	req.SetBasicAuth(cred.Username, cred.Password)

	return req, nil
}

func (c *IBMVAScanner) getAuthenticator(cred credential.Credential) (authenticator RequestAuthenticator, err error) {
	cache := getAuthoriserCache()
	cacheEntry, ok := cache.Map.Load(cred.Password)
	if !ok {
		authenticator, err = c.authenticatorFactory.NewAuthenticator(cred)
		if err != nil {
			return
		}
		cache.Map.Store(cred.Password, authenticator)
	} else {
		authenticator, ok = cacheEntry.(RequestAuthenticator)
		if !ok {
			err = fmt.Errorf("Couldn't cast authenticator")
			return
		}
	}
	return
}

type authenticatorCache struct {
	Map sync.Map
}

var authenticator *authenticatorCache
var once sync.Once

func getAuthoriserCache() *authenticatorCache {
	if authenticator == nil {
		once.Do(
			func() {
				authenticator = &authenticatorCache{}
			})
	}
	return authenticator
}

type RequestAuthenticator interface {
	Authenticate(request *http.Request) error
}

type authenticatorFactoryInterface interface {
	NewAuthenticator(credential.Credential) (RequestAuthenticator, error)
}

type authenticatorFactory struct {
	authenticatorFactoryInterface
}

func (a authenticatorFactory) NewAuthenticator(cred credential.Credential) (RequestAuthenticator, error) {
	return ibmcloud.NewIamAuthenticator(cred.Password, ibmcloud.DEFAULT_IAM_URL, "", "", false, nil)
}
