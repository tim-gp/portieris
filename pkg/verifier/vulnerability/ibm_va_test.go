// Copyright 2020 Portieris Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vulnerability

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"testing"
	"time"

	"github.com/IBM/portieris/helpers/credential"
	"github.com/IBM/portieris/helpers/image"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

type MockHTTP struct {
	mock.Mock
}

func (m *MockHTTP) Do(req *http.Request) (*http.Response, error) {
	args := m.Called(req)
	return args.Get(0).(*http.Response), args.Error(1)
}

func userPasswordToBasicAuth(user, password string) string {
	auth := user + ":" + password
	return "Basic " + base64.StdEncoding.EncodeToString([]byte(auth))
}

type doMock struct {
	inAuthorization string
	outBody         string
	outStatusCode   int
	outErr          error
}

var cred1 = credential.Credential{Username: "user", Password: "pass"}
var singleCreds = credential.Credentials{cred1}
var tripleCreds = credential.Credentials{
	cred1,
	{Username: "user1", Password: "pass1"},
	{Username: "user2", Password: "pass2"},
}

func Test_NewIBMVulnerabilityAdvisorScanner(t *testing.T) {
	c := NewIBMVulnerabilityAdvisorScanner(singleCreds, "123")
	assert.Equal(t, "123", c.AccountHeader)
}

func Test_CanImageDeployBasedOnVulnerabilities(t *testing.T) {
	nonIBMRepo := "mythical.registry/repo:tag"
	ibmRepo := "icr.io/sam/ida:may"
	sleepTime = time.Microsecond
	tests := []struct {
		name           string
		fullImageName  string
		doMock         *doMock
		expectedResult ScanResponse
		expectedError  error
	}{
		{
			name:          "It should error if not an IBM repo",
			fullImageName: nonIBMRepo,
			expectedError: fmt.Errorf("Cannot use IBM Vulnerability Advisor with image %q", nonIBMRepo),
		},
		{
			name:          "It should set CanDeploy `true` when VA returns OK",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "OK"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `true` when VA returns WARN",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "WARN"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `true` when VA returns UNSUPPORTED",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "UNSUPPORTED"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `false` and set DenyReason when VA returns any other status",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "BLOCK"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: false, DenyReason: "Image icr.io/sam/ida:may CANNOT DEPLOY with IBM VA status \"BLOCK\""},
		},
		{
			name:          "It should set CanDeploy `false` and set DenyReason if VA returns an error",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{}`,
				outStatusCode:   http.StatusForbidden,
			},
			expectedResult: ScanResponse{CanDeploy: false, DenyReason: "Image icr.io/sam/ida:may CANNOT DEPLOY due to IBM VA error: \"Not authorised to get IBM vulnerability scan result for \\\"icr.io/sam/ida:may\\\": unauthorised\""},
			expectedError:  fmt.Errorf("Not authorised to get IBM vulnerability scan result for %q: %w", ibmRepo, ErrorUnauthorised),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockHTTP := MockHTTP{}

			if tt.doMock != nil {
				defer mockHTTP.AssertExpectations(t)
				mockHTTP.Test(t)

				request, err := http.NewRequest("GET", "https://icr.io/va/api/v3/report/image/status/"+tt.fullImageName, nil)
				require.NoError(t, err)
				request.Header.Add("Authorization", tt.doMock.inAuthorization)

				response := http.Response{
					StatusCode: tt.doMock.outStatusCode,
					Body:       ioutil.NopCloser(bytes.NewBuffer([]byte(tt.doMock.outBody))),
				}
				mockHTTP.On("Do", request).Return(&response, tt.doMock.outErr).Once()
			}

			client := IBMVAScanner{
				credentials: credential.Credentials{
					{
						Username: "user",
						Password: "pass",
					},
				},
				client: &mockHTTP,
			}

			image, err := image.NewReference(tt.fullImageName)
			require.NoError(t, err)

			result, err := client.CanImageDeployBasedOnVulnerabilities(*image)

			assert.Equal(t, tt.expectedResult, result)
			assert.Equal(t, tt.expectedError, err)
		})
	}

}

func Test_getImageStatus(t *testing.T) {
	sleepTime = time.Microsecond
	tests := []struct {
		name           string
		credentials    credential.Credentials
		accountHeader  string
		fullImageName  string
		doMocks        []doMock
		expectedResult IBMVASummary
		expectedError  error
	}{
		{
			name:          "It should call the VA API and return a result when image is tagged",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should call the VA API and return a result when image is by digest",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida@sha256:abc",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should include the Account header when calling VA if set",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			accountHeader:  "anaccount",
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should try different credentials if the VA API returns 401 or 403",
			credentials:   tripleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusForbidden,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user2", "pass2"),
					outStatusCode:   http.StatusOK,
					outBody:         `{"status": "OK"}`,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "All creds return unauthorised",
			credentials:   tripleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user2", "pass2"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Not authorised to get IBM vulnerability scan result for \"icr.io/sam/ida:latest\": %w", ErrorUnauthorised),
		},
		{
			name: "try again 3 times for an internal server error",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusServiceUnavailable,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusInternalServerError,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusBadGateway,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": %v", "Internal server error"),
		},
		{
			name: "Retry three times and then error for unexpected 5** responses",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": Unhandled response from IBM Vulnerability Advisor"),
		},
		{
			name: "Retry three times and then error for client.Do failing",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": uh oh"),
		},
		{
			name: "Return decoding error if VA response is not valid JSON",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusOK,
					outBody:         `{"issue_count": "nan"}`,
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": json: cannot unmarshal string into Go struct field IBMVASummary.issue_count of type int"),
		},
		{
			name: "If image isn't found, return error and don't call VA again",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
				{Username: "user2", Password: "pass2"},
				{Username: "user3", Password: "pass3"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   404,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": %v", "Not found"),
		},
		{
			name: "If bad request response, return error and don't try again",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
				{Username: "user2", Password: "pass2"},
				{Username: "user3", Password: "pass3"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   400,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get IBM vulnerability advisor scan result for \"icr.io/sam/ida:latest\": %v", "Bad request"),
		},
		{
			name:          "If there are no credentials on the client, error",
			credentials:   credential.Credentials{},
			fullImageName: "icr.io/sam/ida:latest",
			expectedError: fmt.Errorf("No credentials on client to call VA with"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockHTTP := MockHTTP{}
			defer mockHTTP.AssertExpectations(t)
			mockHTTP.Test(t)

			for _, mockDo := range tt.doMocks {
				request, err := http.NewRequest("GET", "https://icr.io/va/api/v3/report/image/status/"+tt.fullImageName, nil)
				require.NoError(t, err)
				request.Header.Add("Authorization", mockDo.inAuthorization)
				if tt.accountHeader != "" {
					request.Header.Add("Account", tt.accountHeader)
				}

				response := http.Response{
					StatusCode: mockDo.outStatusCode,
					Body:       ioutil.NopCloser(bytes.NewBuffer([]byte(mockDo.outBody))),
				}
				//todo check the cred on the request, not just mock anything
				mockHTTP.On("Do", request).Return(&response, mockDo.outErr).Once()
			}

			client := IBMVAScanner{
				credentials:   tt.credentials,
				client:        &mockHTTP,
				AccountHeader: tt.accountHeader,
			}

			image, err := image.NewReference(tt.fullImageName)
			require.NoError(t, err)

			result, err := client.getImageStatus(*image)

			assert.Equal(t, tt.expectedResult, result)
			assert.Equal(t, tt.expectedError, err)
		})
	}

}
